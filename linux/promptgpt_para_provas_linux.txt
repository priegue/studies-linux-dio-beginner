Prompt para criar script de prova Linux personalizado:

    Ol√°, preciso criar um script Bash que funcione como uma prova interativa para testar conhecimentos de comandos Linux.

    Requisitos principais:

        O script deve criar um diret√≥rio chamado prova_de_comandos para armazenar todos os arquivos criados/executados durante a prova.

        Cada quest√£o mostrar√° uma descri√ß√£o simples do comando, seguida de uma pergunta.

        O usu√°rio deve digitar o comando correto para executar a tarefa pedida.

        O script vai executar o comando realmente dentro do diret√≥rio prova_de_comandos, simulando o ambiente, sem afetar o restante do sistema.

        Se o comando estiver correto, o script confirma, registra acertos e avan√ßa para a pr√≥xima quest√£o automaticamente.

        Se estiver incorreto, oferece op√ß√£o para tentar novamente ou sair (e apagar o diret√≥rio criado).

        Ao finalizar a prova (ou sair antecipadamente), o script mostra um resumo de acertos e erros, exibe o conte√∫do final da pasta prova_de_comandos, e d√° op√ß√£o de apagar ou manter essa pasta.

        O script deve ter uma interface amig√°vel, com cores e prompts do tipo usuario@servidor1:~$.

    Por favor, crie esse script deixando um espa√ßo no c√≥digo onde eu possa simplesmente inserir os comandos que quero testar na prova, com suas descri√ß√µes e perguntas correspondentes.

    Exemplo do formato de entrada para as perguntas:

        comandos=( "mkdir teste" "touch arquivo1.txt" "ls" )

        descricoes=( "Cria um diret√≥rio" "Cria um arquivo vazio" "Lista arquivos e diret√≥rios" )

        perguntas=( "Digite o comando para criar um diret√≥rio chamado 'teste'." "Digite o comando para criar um arquivo vazio chamado 'arquivo1.txt'." "Digite o comando para listar arquivos." )

    Aguardo o script completo para que eu possa apenas editar esses arrays para montar provas personalizadas.

SCRIPT MODELO PARA 5 QUEST√ïES
PROVA_DE_COMANDOS.SH

    #!/bin/bash
    
    # Cores para sa√≠da
    VERDE="\e[32m"
    VERMELHO="\e[31m"
    AZUL="\e[34m"
    AMARELO="\e[33m"
    NEUTRO="\e[0m"
    
    # Diret√≥rio para armazenar prova
    DIR_PROVA="prova_de_comandos"
    
    # Cria o diret√≥rio da prova se n√£o existir
    mkdir -p "$DIR_PROVA"
    
    acertos=0
    erros=0
    
    # Quest√µes e comandos reais para executar dentro do dir
    perguntas=(
    "Digite o comando para criar um diret√≥rio chamado 'teste'."
    "Digite o comando para criar um arquivo vazio chamado 'arquivo1.txt'."
    "Digite o comando para listar os arquivos no diret√≥rio atual."
    "Digite o comando para remover o arquivo 'arquivo1.txt'."
    "Digite o comando para remover o diret√≥rio 'teste'."
    )
    
    comandos=(
    "mkdir teste"
    "touch arquivo1.txt"
    "ls"
    "rm arquivo1.txt"
    "rmdir teste"
    )
    
    descricoes=(
    "Cria um diret√≥rio."
    "Cria um arquivo vazio."
    "Lista arquivos e diret√≥rios."
    "Remove um arquivo."
    "Remove um diret√≥rio vazio."
    )
    
    function limpar_tela {
        clear
    }
    
    function executar_comando_real {
        # Executa comando dentro do diret√≥rio prova_de_comandos e captura sa√≠da e erros
        # Recebe comando completo como argumento
        local cmd="$1"
        # Executa no contexto do diret√≥rio da prova
        (cd "$DIR_PROVA" && eval "$cmd" 2>/dev/null)
    }
    
    function mostrar_conteudo_final {
        echo ""
        echo -e "${AMARELO}Conte√∫do atual de '$DIR_PROVA':${NEUTRO}"
        ls -l "$DIR_PROVA"
        echo ""
    }
    
    # Loop das quest√µes
    for i in "${!perguntas[@]}"; do
        repetir_questao=true
        while $repetir_questao; do
            limpar_tela
            echo -e "${AZUL}=============================="
            echo -e "     Prova de Comandos Linux"
            echo -e "==============================${NEUTRO}"
            echo ""
            echo -e "${AMARELO}Quest√£o $((i+1)) de ${#perguntas[@]}${NEUTRO}"
            echo -e "Descri√ß√£o: ${descricoes[$i]}"
            echo -e "Pergunta: ${perguntas[$i]}"
            echo ""
            echo -en "usuario@servidor1:~$ "
            read resposta
    
            if [[ "$resposta" == "${comandos[$i]}" ]]; then
                # Executa o comando no diret√≥rio prova_de_comandos
                executar_comando_real "$resposta"
                echo -e "${VERDE}‚úÖ Resposta correta!"
                echo -e "Parab√©ns: Comando '${resposta}' executado.${NEUTRO}"
                echo ""
                ((acertos++))
    
                # Pergunta se deseja finalizar ou continuar (exceto √∫ltima quest√£o)
                if [[ $i -lt $(( ${#perguntas[@]} - 1 )) ]]; then
                    echo -e "1) Finalizar a prova agora"
                    echo -e "Pressione Enter para continuar para a pr√≥xima quest√£o."
                    read -p "Escolha uma op√ß√£o: " opcao
                    if [[ "$opcao" == "1" ]]; then
                        mostrar_conteudo_final
                        # Apaga a prova e sai
                        rm -rf "$DIR_PROVA"
                        echo -e "${AMARELO}Diret√≥rio '$DIR_PROVA' apagado. Saindo...${NEUTRO}"
                        exit 0
                    fi
                else
                    # √öltima quest√£o, vai para op√ß√µes finais
                    repetir_questao=false
                fi
                repetir_questao=false
    
            elif [[ "$resposta" == "n√£o sei" ]]; then
                ((erros++))
                echo -e "${VERMELHO}‚ùå Resposta correta √©: ${comandos[$i]}${NEUTRO}"
                echo -e "${VERMELHO}üìö Estude mais um pouco e tente novamente.${NEUTRO}"
                echo ""
                echo -e "1) Tentar novamente"
                echo -e "2) Sair (apaga a prova)"
                read -p "Escolha uma op√ß√£o: " opcao
                if [[ "$opcao" == "2" ]]; then
                    mostrar_conteudo_final
                    rm -rf "$DIR_PROVA"
                    echo -e "${AMARELO}Diret√≥rio '$DIR_PROVA' apagado. Saindo...${NEUTRO}"
                    exit 0
                fi
            else
                ((erros++))
                echo -e "${VERMELHO}‚ùå Resposta incorreta.${NEUTRO}"
                echo ""
                echo -e "1) Tentar novamente"
                echo -e "2) Sair (apaga a prova)"
                read -p "Escolha uma op√ß√£o: " opcao
                if [[ "$opcao" == "2" ]]; then
                    mostrar_conteudo_final
                    rm -rf "$DIR_PROVA"
                    echo -e "${AMARELO}Diret√≥rio '$DIR_PROVA' apagado. Saindo...${NEUTRO}"
                    exit 0
                fi
            fi
        done
    done
    
    # Final da prova
    while true; do
        limpar_tela
        echo -e "${AZUL}=============================="
        echo -e "        Prova finalizada"
        echo -e "==============================${NEUTRO}"
        echo -e "‚úÖ Acertos = ${VERDE}$acertos${NEUTRO}"
        echo -e "‚ùå Erros = ${VERMELHO}$erros${NEUTRO}"
        mostrar_conteudo_final
        echo -e "1) Apagar o diret√≥rio da prova e sair"
        echo -e "2) Sair sem apagar o diret√≥rio"
        echo -en "Escolha uma op√ß√£o: "
        read escolha
        case $escolha in
            1)
                rm -rf "$DIR_PROVA"
                echo -e "${AMARELO}Diret√≥rio '$DIR_PROVA' apagado. Saindo...${NEUTRO}"
                exit 0
                ;;
            2)
                echo -e "${AMARELO}Saindo sem apagar o diret√≥rio '$DIR_PROVA'.${NEUTRO}"
                exit 0
                ;;
            *)
                echo -e "${VERMELHO}Op√ß√£o inv√°lida. Tente novamente.${NEUTRO}"
                sleep 1
                ;;
        esac
    done


DEPOIS DE CRIAR O SCRIPT

chmod +x prova_linux_real.sh

./prova_linux_real.sh

